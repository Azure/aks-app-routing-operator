apiVersion: v1
kind: ServiceAccount
metadata:
  name: server

---

apiVersion: apps/v1
kind: Deployment
metadata:
  name: server
  labels:
    app: server
spec:
  replicas: 2
  selector:
    matchLabels:
      app: server
  template:
    metadata:
      labels:
        app: server
    spec:
      serviceAccountName: server
      containers:
      - name: server
        image: golang:1.18
        env:
        - name: MAX_SLEEP_DURATION
          value: "1s"
        command:
        - /bin/sh
        - -c
        - |
          mkdir server && cd server && go mod init server

          cat > main.go <<EOF
            package main
            
            import (
            	"log"
            	"math/rand"
            	"net/http"
            	"os"
            	"sync/atomic"
            	"time"
            )
            
            var letterBytes = []byte("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
            
            var output = make([]byte, 1024*1024)
            
            func init() {
            	rand.Seed(time.Now().UnixNano())
            	for i := range output {
            		output[i] = letterBytes[rand.Intn(len(letterBytes))]
            	}
            }
            
            func main() {
            	maxSleep, err := time.ParseDuration(os.Getenv("MAX_SLEEP_DURATION"))
            	if err != nil {
            		panic(err)
            	}
            
            	var active int64
            	go func() {
            		for {
            			<-time.After(time.Second)
            			log.Printf("active conns: %d", atomic.LoadInt64(&active))
            		}
            	}()
            
            	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
            		atomic.AddInt64(&active, 1)
            		defer atomic.AddInt64(&active, -1)
            		w.Write(output[:rand.Intn(len(output)-1)])
            		time.Sleep(time.Millisecond * time.Duration(rand.Intn(int(maxSleep.Milliseconds()))))
            	})
            
            	http.HandleFunc("/sleep", func(w http.ResponseWriter, r *http.Request) {
            		atomic.AddInt64(&active, 1)
            		defer atomic.AddInt64(&active, -1)
            		<-r.Context().Done()
            	})
            
            	panic(http.ListenAndServe(":8080", nil))
            }
          EOF

          go run main.go

---

apiVersion: v1
kind: Service
metadata:
  name: server
spec:
  type: ClusterIP
  selector:
    app: server
  ports:
  - port: 80
    protocol: TCP
    targetPort: 8080
